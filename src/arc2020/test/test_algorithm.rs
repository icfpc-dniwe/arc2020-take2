#[cfg(test)]
mod test_operations {
    use crate::arc2020::types::*;
    use crate::arc2020::algorithm::*;
    use anyhow::Result;

    fn gen_test_image1() -> Image
    {
        // returns:
        // (Y)
        //    +---+---+---+---+---+---+---+---+
        //  8 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  7 | 1 | 1 | 0 | 0 | 0 | 0 | 5 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  6 | 1 | 0 | 2 | 2 | 2 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  5 | 0 | 2 | 1 | 1 | 2 | 2 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  4 | 0 | 2 | 1 | 1 | 0 | 2 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  3 | 0 | 2 | 0 | 2 | 2 | 3 | 3 | 3 |
        //    +---+---+---+---+---+---+---+---+
        //  2 | 0 | 0 | 2 | 0 | 0 | 3 | 6 | 3 |
        //    +---+---+---+---+---+---+---+---+
        //  1 | 0 | 0 | 0 | 0 | 2 | 6 | 3 | 6 |
        //    +---+---+---+---+---+---+---+---+
        //  0 | 2 | 2 | 2 | 2 | 2 | 6 | 6 | 6 |
        //    +---+---+---+---+---+---+---+---+
        //      0   1   2   3   4   5   6   7   (X)

        let mut img = Image::default((8, 9));
        img.fill(0);
        // object (color 2)
        img[(0, 0)] = 2;
        img[(1, 0)] = 2;
        img[(2, 0)] = 2;
        img[(3, 0)] = 2;
        img[(4, 0)] = 2;
        img[(4, 1)] = 2;
        // object (color 2)
        img[(2, 2)] = 2;
        img[(1, 3)] = 2;
        img[(1, 4)] = 2;
        img[(1, 5)] = 2;
        img[(2, 6)] = 2;
        img[(3, 6)] = 2;
        img[(4, 6)] = 2;
        img[(4, 5)] = 2;
        img[(5, 5)] = 2;
        img[(5, 4)] = 2;
        img[(4, 3)] = 2;
        img[(3, 3)] = 2;
        // object (color 1)
        img[(0, 8)] = 1;
        img[(1, 8)] = 1;
        img[(0, 7)] = 1;
        img[(1, 7)] = 1;
        img[(0, 6)] = 1;
        // object (color 1)
        img[(2, 5)] = 1;
        img[(2, 4)] = 1;
        img[(3, 5)] = 1;
        img[(3, 4)] = 1;
        // object (color 6)
        img[(5, 0)] = 6;
        img[(5, 1)] = 6;
        img[(6, 2)] = 6;
        img[(7, 1)] = 6;
        img[(7, 0)] = 6;
        img[(6, 0)] = 6;
        // object (color 3)
        img[(6, 1)] = 3;
        img[(5, 2)] = 3;
        img[(5, 3)] = 3;
        img[(6, 3)] = 3;
        img[(7, 3)] = 3;
        img[(7, 2)] = 3;
        return img;
    }

    fn gen_test_image2() -> Image
    {
        // returns:
        // (Y)
        //    +---+---+---+---+---+---+---+---+
        //  8 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  7 | 0 | 2 | 0 | 0 | 2 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  6 | 0 | 2 | 2 | 0 | 2 | 2 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  5 | 0 | 0 | 2 | 0 | 2 | 0 | 2 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  4 | 0 | 0 | 2 | 0 | 2 | 0 | 2 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  3 | 0 | 0 | 0 | 2 | 2 | 2 | 2 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  2 | 2 | 2 | 2 | 0 | 2 | 2 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  1 | 0 | 2 | 0 | 2 | 0 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //  0 | 0 | 0 | 2 | 2 | 0 | 0 | 0 | 0 |
        //    +---+---+---+---+---+---+---+---+
        //      0   1   2   3   4   5   6   7   (X)

        let mut img = Image::default((8, 9));
        img.fill(0);
        // object (color 2)
        img[(2, 0)] = 2;
        img[(3, 0)] = 2;
        img[(1, 1)] = 2;
        img[(3, 1)] = 2;
        img[(0, 2)] = 2;
        img[(1, 2)] = 2;
        img[(2, 2)] = 2;
        img[(4, 2)] = 2;
        img[(5, 2)] = 2;
        img[(3, 3)] = 2;
        img[(4, 3)] = 2;
        img[(5, 3)] = 2;
        img[(6, 3)] = 2;
        img[(2, 4)] = 2;
        img[(4, 4)] = 2;
        img[(6, 4)] = 2;
        img[(2, 5)] = 2;
        img[(4, 5)] = 2;
        img[(6, 5)] = 2;
        img[(1, 6)] = 2;
        img[(2, 6)] = 2;
        img[(4, 6)] = 2;
        img[(5, 6)] = 2;
        img[(1, 7)] = 2;
        img[(4, 7)] = 2;
        return img;
    }

    fn neigh8(p0 : &(usize, usize), p1 : &(usize, usize)) -> bool
    {
        let ns : [(i64, i64); 8] = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)];
        for n in ns.iter()
        {
            if (((p0.0 as i64) + n.0) as usize) == p1.0 && (((p0.1 as i64) + n.1) as usize) == p1.1
            {
                return true;
            }
        }
        return false;
    }

    fn neigh4(p0 : &(usize, usize), p1 : &(usize, usize)) -> bool
    {
        let ns : [(i64, i64); 4] = [(0, 1), (1, 0), (0, -1), (-1, 0)];
        for n in ns.iter()
        {
            if (((p0.0 as i64) + n.0) as usize) == p1.0 && (((p0.1 as i64) + n.1) as usize) == p1.1
            {
                return true;
            }
        }
        return false;
    }


    #[test]
    fn test_extract_objects() -> Result<()>
    {
        {
            let img = gen_test_image1();
            let objs = extract_objects(&img, 0, neigh8)?;
            assert_eq!(objs.len(), 6);
        }

        {
            let img = gen_test_image2();
            let objs = extract_objects(&img, 0, neigh8)?;
            assert_eq!(objs.len(), 1);
        }

        {
            let img = gen_test_image2();
            let objs = extract_objects(&img, 0, neigh4)?;
            assert_eq!(objs.len(), 4);
        }

        Ok(())
    }
}